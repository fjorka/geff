{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geff!","text":"<p>geff is a specification for a file format for exchanging spatial graph data. It is not intended to be mutable, editable, chunked, or optimized for use in an application setting.</p> <p>geff is the specification of the file format, but the library also includes implementations for writing from and reading to a networkx graph, a common Python in-memory graph data structure. The library uses semantic versioning, where changes to the specification bump the major or minor versions, and bugfixes for the example implementation bumps the patch version.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install geff\n</code></pre>"},{"location":"specification/","title":"Geff specification","text":"<p>The graph exchange file format is <code>zarr</code> based. A graph is stored in a zarr group, which can have any name. This allows storing multiple <code>geff</code> graphs inside the same zarr root directory. A <code>geff</code> group is identified by the presence of a <code>geff_version</code> attribute in the <code>.zattrs</code>. Other <code>geff</code> metadata is also stored in the <code>.zattrs</code> file of the <code>geff</code> group. The <code>geff</code> group must contain a <code>nodes</code> group and an <code>edges</code> group.</p>"},{"location":"specification/#geff-metadata","title":"Geff metadata geff_version Required  directed Required  roi_min Required  roi_max Required  position_attr  axis_names  Any of  axis_units  Any of","text":"geff_metadata geff_metadataType: object <p>Geff metadata schema to validate the attributes json file in a geff zarr</p> root          geff_versionGeff VersionType: string Must match regular expression: <code>(0\\.0)|(0\\.1)</code> root          directedDirectedType: boolean root          roi_minRoi MinType: array of number No Additional ItemsEach item of this array must be: root          roi_min roi_min itemsType: number root          roi_maxRoi MaxType: array of number No Additional ItemsEach item of this array must be: root          roi_max roi_max itemsType: number root          position_attrPosition AttrType: string Default: \"position\" root          axis_namesAxis Names Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          axis_names anyOf item 0Type: array of string No Additional ItemsEach item of this array must be: root          axis_names anyOf item 0 item 0 itemsType: string root          axis_names anyOf item 1Type: null root          axis_unitsAxis Units Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          axis_units anyOf item 0Type: array of string No Additional ItemsEach item of this array must be: root          axis_units anyOf item 0 item 0 itemsType: string root          axis_units anyOf item 1Type: null <p>Generated using json-schema-for-humans on 2025-05-02 at 14:20:57 +0000</p>"},{"location":"specification/#the-nodes-group","title":"The <code>nodes</code> group","text":"<p>The nodes group will contain an <code>ids</code> array and an <code>attrs</code> group.</p>"},{"location":"specification/#the-ids-array","title":"The <code>ids</code> array","text":"<p>The <code>nodes\\ids</code> array is a 1D array of node IDs of length <code>N</code> &gt; 0, where <code>N</code> is the number of nodes in the graph. Node ids must be unique. Node IDs can have any type supported by zarr, but we recommend integer dtypes. For large graphs, <code>uint64</code> might be necessary to provide enough range for every node to have a unique ID. </p>"},{"location":"specification/#the-attrs-group-and-node-attribute-groups","title":"The <code>attrs</code> group and <code>node attribute</code> groups","text":"<p>The <code>nodes\\attrs</code> group will contain one or more <code>node attribute</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array. </p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the node <code>ids</code> array, such that each row of the attribute <code>values</code> array stores the attribute for the node at that index in the ids array. </li> <li>The <code>missing</code> array is an optional, a one dimensional boolean array to support attributes that are not present on all nodes. A 1 at an index in the <code>missing</code> array indicates that the <code>value</code> of that attribute for the node at that index is None, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all nodes have values for the attribute. </li> </ul> <p>Note</p> <p>When writing a graph with missing attributes to the geff format, you must fill in a dummy value in the <code>values</code> array for the nodes that are missing the attribute, in order to keep the indices aligned with the node ids.</p> <ul> <li>The <code>position</code> group is a special node attribute group that must be present and does not allow missing attributes.</li> <li>The <code>seg_id</code> group is an optional, special node attribute group that stores the segmenatation label for each node. The <code>seg_id</code> values do not need to be unique, in case labels are repeated between time points. If the <code>seg_id</code> group is not present, it is assumed that the graph is not associated with a segmentation. </li> </ul>"},{"location":"specification/#the-edges-group","title":"The <code>edges</code> group","text":"<p>Similar to the <code>nodes</code> group, the <code>edges</code> group will contain an <code>ids</code> array and an <code>attrs</code> group. If there are no edges in the graph, the edge group is not created.</p>"},{"location":"specification/#the-ids-array_1","title":"The <code>ids</code> array","text":"<p>The <code>edges\\ids</code> array is a 2D array with the same dtype as the <code>nodes\\ids</code> array. It has shape <code>(2, E)</code>, where <code>E</code> is the number of edges in the graph. All elements in the <code>edges\\ids</code> array must also be present in the <code>nodes\\ids</code> array. Each row represents an edge between two nodes. For directed graphs, the first column is the source nodes and the second column holds the target nodes. For undirected graphs, the order is arbitrary. Edges should be unique (no multiple edges between the same two nodes) and edges from a node to itself are not supported.</p>"},{"location":"specification/#the-attrs-group-and-edge-attribute-groups","title":"The <code>attrs</code> group and <code>edge attribute</code> groups","text":"<p>The <code>edges\\attrs</code> group will contain zero or more <code>edge attribute</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array. </p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the <code>edges\\ids</code> array, such that each row of the attribute <code>values</code> array stores the attribute for the edge at that index in the ids array. </li> <li>The <code>missing</code> array is an optional, a one dimensional boolean array to support attributes that are not present on all edges. A 1 at an index in the <code>missing</code> array indicates that the <code>value</code> of that attribute for the edge at that index is missing, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all edges have values for the attribute.</li> </ul> <p>If you do not have any edge attributes, the <code>edges\\attrs</code> group should still be present, but empty.</p>"},{"location":"specification/#example-file-structure-and-metadata","title":"Example file structure and metadata","text":"<p>TODO: Example metadata for this file structure <pre><code>/path/to.zarr\n    /tracking_graph\n        .zattrs  # graph metadata with `geff_version`\n        nodes/\n            ids  # shape: (N,)  dtype: uint64\n            attrs/\n                position/\n                    values # shape: (N, 3) dtype: float16\n                color/\n                    values # shape: (N, 4) dtype: float16\n                    missing # shape: (N,) dtype: bool\n        edges/\n            ids  # shape: (E, 2) dtype: uint64\n            attrs/\n                distance/\n                    values # shape: (E,) dtype: float16\n                score/\n                    values # shape: (E,) dtype: float16\n                    missing # shape: (E,) dtype: bool\n    # optional:\n    /segmentation \n\n    # unspecified, but totally okay:\n    /raw \n</code></pre></p>"},{"location":"what-is-geff/","title":"What is geff?","text":"<p><code>geff</code> is a graph exchange file format that seeks to fulfill the following needs: - Provide a storage/exchange format for graphs and optional segmentation - Provide a common API with reference implementations for use in other projects</p>"},{"location":"what-is-geff/#design-decisions-and-assumptions","title":"Design Decisions and Assumptions","text":"<ul> <li>Raw image data is not included in the <code>geff</code> spec. However, to keep nodes linked to segmentation labels, support for specifying the seg_id of each node in a standard way, along with the path to the segmentation, are included in the <code>spec</code>.</li> <li>Since <code>geff</code> is an exchange format, we do not provide support for searching or filtering.</li> <li>We do not provide support for editing or changing the graph on the fly.</li> <li>In order to support efficient reading/writing, we assume the graph can fit into memory.</li> </ul>"},{"location":"reference/geff/","title":"geff","text":""},{"location":"reference/geff/#geff","title":"geff","text":"<p>Modules:</p> <ul> <li> <code>metadata_schema</code>           \u2013            </li> <li> <code>networkx</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/geff/metadata_schema/","title":"geff.metadata_schema","text":""},{"location":"reference/geff/metadata_schema/#geff.metadata_schema","title":"geff.metadata_schema","text":"<p>Classes:</p> <ul> <li> <code>GeffMetadata</code>           \u2013            <p>Geff metadata schema to validate the attributes json file in a geff zarr</p> </li> </ul>"},{"location":"reference/geff/metadata_schema/#geff.metadata_schema.GeffMetadata","title":"GeffMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geff metadata schema to validate the attributes json file in a geff zarr</p> <p>Methods:</p> <ul> <li> <code>read</code>             \u2013              <p>Helper function to read GeffMetadata from a zarr geff group.</p> </li> <li> <code>write</code>             \u2013              <p>Helper function to write GeffMetadata into the zarr geff group.</p> </li> </ul>"},{"location":"reference/geff/metadata_schema/#geff.metadata_schema.GeffMetadata.read","title":"read  <code>classmethod</code>","text":"<pre><code>read(group: Group | Path) -&gt; GeffMetadata\n</code></pre> <p>Helper function to read GeffMetadata from a zarr geff group.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GeffMetadata</code> (              <code>GeffMetadata</code> )          \u2013            <p>The GeffMetadata object</p> </li> </ul> Source code in <code>src/geff/metadata_schema.py</code> <pre><code>@classmethod\ndef read(cls, group: zarr.Group | Path) -&gt; GeffMetadata:\n    \"\"\"Helper function to read GeffMetadata from a zarr geff group.\n\n    Args:\n        group (zarr.Group | Path): The zarr group containing the geff metadata\n\n    Returns:\n        GeffMetadata: The GeffMetadata object\n    \"\"\"\n    if isinstance(group, Path):\n        group = zarr.open(group)\n    return cls(**group.attrs)\n</code></pre>"},{"location":"reference/geff/metadata_schema/#geff.metadata_schema.GeffMetadata.read(group)","title":"<code>group</code>","text":"(<code>Group | Path</code>)           \u2013            <p>The zarr group containing the geff metadata</p>"},{"location":"reference/geff/metadata_schema/#geff.metadata_schema.GeffMetadata.write","title":"write","text":"<pre><code>write(group: Group | Path)\n</code></pre> <p>Helper function to write GeffMetadata into the zarr geff group.</p> <p>Parameters:</p> Source code in <code>src/geff/metadata_schema.py</code> <pre><code>def write(self, group: zarr.Group | Path):\n    \"\"\"Helper function to write GeffMetadata into the zarr geff group.\n\n    Args:\n        group (zarr.Group | Path): The geff group to write the metadata to\n    \"\"\"\n    if isinstance(group, Path):\n        group = zarr.open(group)\n    for key, value in self:\n        group.attrs[key] = value\n</code></pre>"},{"location":"reference/geff/metadata_schema/#geff.metadata_schema.GeffMetadata.write(group)","title":"<code>group</code>","text":"(<code>Group | Path</code>)           \u2013            <p>The geff group to write the metadata to</p>"},{"location":"reference/geff/networkx/","title":"geff.networkx","text":""},{"location":"reference/geff/networkx/#geff.networkx","title":"geff.networkx","text":"<p>Modules:</p> <ul> <li> <code>io</code>           \u2013            </li> </ul>"},{"location":"reference/geff/networkx/io/","title":"geff.networkx.io","text":""},{"location":"reference/geff/networkx/io/#geff.networkx.io","title":"geff.networkx.io","text":"<p>Functions:</p> <ul> <li> <code>get_edge_attrs</code>             \u2013              <p>Get the attribute keys present on any edge in the networkx graph. Does not imply</p> </li> <li> <code>get_node_attrs</code>             \u2013              <p>Get the attribute keys present on any node in the networkx graph. Does not imply</p> </li> <li> <code>get_roi</code>             \u2013              <p>Get the roi of a networkx graph.</p> </li> <li> <code>read</code>             \u2013              <p>Read a geff file into a networkx graph. Metadata attributes will be stored in</p> </li> <li> <code>write</code>             \u2013              <p>Write a networkx graph to the geff file format</p> </li> </ul>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_edge_attrs","title":"get_edge_attrs","text":"<pre><code>get_edge_attrs(graph: Graph) -&gt; list[str]\n</code></pre> <p>Get the attribute keys present on any edge in the networkx graph. Does not imply that the attributes are present on all edges.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all unique edge attribute keys</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_edge_attrs(graph: nx.Graph) -&gt; list[str]:\n    \"\"\"Get the attribute keys present on any edge in the networkx graph. Does not imply\n    that the attributes are present on all edges.\n\n    Args:\n        graph (nx.Graph): a networkx graph\n\n    Returns:\n        list[str]: A list of all unique edge attribute keys\n    \"\"\"\n    return list({k for e in graph.edges for k in graph.edges[e]})\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_node_attrs","title":"get_node_attrs","text":"<pre><code>get_node_attrs(graph: Graph) -&gt; list[str]\n</code></pre> <p>Get the attribute keys present on any node in the networkx graph. Does not imply that the attributes are present on all nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all unique node attribute keys</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_node_attrs(graph: nx.Graph) -&gt; list[str]:\n    \"\"\"Get the attribute keys present on any node in the networkx graph. Does not imply\n    that the attributes are present on all nodes.\n\n    Args:\n        graph (nx.Graph): a networkx graph\n\n    Returns:\n        list[str]: A list of all unique node attribute keys\n    \"\"\"\n    return list({k for n in graph.nodes for k in graph.nodes[n]})\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi","title":"get_roi","text":"<pre><code>get_roi(graph: Graph, position_attr: str) -&gt; tuple[tuple[float, ...], tuple[float, ...]]\n</code></pre> <p>Get the roi of a networkx graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[tuple[float, ...], tuple[float, ...]]</code>           \u2013            <p>tuple[tuple[float, ...], tuple[float, ...]]: A tuple with the min values in each spatial dim, and a tuple with the max values in each spatial dim</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_roi(graph: nx.Graph, position_attr: str) -&gt; tuple[tuple[float, ...], tuple[float, ...]]:\n    \"\"\"Get the roi of a networkx graph.\n\n    Args:\n        graph (nx.Graph): A non-empty networkx graph\n        position_attr (str): All nodes on graph have this attribute holding their position\n\n    Returns:\n        tuple[tuple[float, ...], tuple[float, ...]]: A tuple with the min values in each\n            spatial dim, and a tuple with the max values in each spatial dim\n    \"\"\"\n    _min = None\n    _max = None\n    for _, data in graph.nodes(data=True):\n        pos = np.array(data[position_attr])\n        if _min is None:\n            _min = pos\n            _max = pos\n        else:\n            _min = np.min([_min, pos], axis=0)\n            _max = np.max([_max, pos], axis=0)\n\n    return tuple(_min.tolist()), tuple(_max.tolist())  # type: ignore\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>A non-empty networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>)           \u2013            <p>All nodes on graph have this attribute holding their position</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.read","title":"read","text":"<pre><code>read(path: Path | str, validate: bool = True) -&gt; nx.Graph\n</code></pre> <p>Read a geff file into a networkx graph. Metadata attributes will be stored in the graph attributes, accessed via <code>G.graph[key]</code> where G is a networkx graph.</p> <p>Parameters:</p> <p>Returns:     nx.Graph: The graph that was stored in the geff file format</p> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def read(path: Path | str, validate: bool = True) -&gt; nx.Graph:\n    \"\"\"Read a geff file into a networkx graph. Metadata attributes will be stored in\n    the graph attributes, accessed via `G.graph[key]` where G is a networkx graph.\n\n    Args:\n        path (Path | str): The path to the root of the geff zarr, where the .attrs contains\n            the geff  metadata\n    Returns:\n        nx.Graph: The graph that was stored in the geff file format\n    \"\"\"\n    # zarr python 3 doesn't support Path\n    path = str(path)\n\n    # open zarr container\n    if validate:\n        geff.utils.validate(path)\n\n    group = zarr.open(path, mode=\"r\")\n    metadata = GeffMetadata.read(group)\n\n    # read meta-data\n    graph = nx.DiGraph() if metadata.directed else nx.Graph()\n    for key, val in metadata:\n        graph.graph[key] = val\n\n    nodes = group[\"nodes/ids\"][:]\n    graph.add_nodes_from(nodes.tolist())\n\n    # collect node attributes\n    for name in group[\"nodes/attrs\"]:\n        _set_attribute_values(graph, nodes, group, name, nodes=True)\n\n    if \"edges\" in group.group_keys():\n        edges = group[\"edges/ids\"][:]\n        graph.add_edges_from(edges.tolist())\n\n        # collect edge attributes\n        for name in group[\"edges/attrs\"]:\n            _set_attribute_values(graph, edges, group, name, nodes=False)\n\n    return graph\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.read(path)","title":"<code>path</code>","text":"(<code>Path | str</code>)           \u2013            <p>The path to the root of the geff zarr, where the .attrs contains the geff  metadata</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write","title":"write","text":"<pre><code>write(graph: Graph, position_attr: str, path: str | Path, axis_names: list[str] | None = None, axis_units: list[str] | None = None, zarr_format: int = 3, validate: bool = True)\n</code></pre> <p>Write a networkx graph to the geff file format</p> <p>Parameters:</p> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def write(\n    graph: nx.Graph,\n    position_attr: str,\n    path: str | Path,\n    axis_names: list[str] | None = None,\n    axis_units: list[str] | None = None,\n    zarr_format: int = 3,\n    validate: bool = True,\n):\n    \"\"\"Write a networkx graph to the geff file format\n\n    Args:\n        graph (nx.Graph): a networkx graph where every node has a position attribute\n        position_attr (str): the name of the position attribute present on every node\n        path (str | Path): the path to the output zarr. Opens in append mode,\n            so will only overwrite geff-controlled groups.\n        axis_names (Optional[list[str]], optional): The names of the spatial dims\n            represented in position attribute. Defaults to None. Will override\n            value in graph attributes if provided.\n        axis_units (Optional[list[str]], optional): The units of the spatial dims\n            represented in position attribute. Defaults to None. Will override value\n            in graph attributes if provided.\n        zarr_format (Optional[int], optional): The version of zarr to write.\n            Defaults to 3.\n        validate (bool, optional): Flag indicating whether to perform validation on the\n            networkx graph before writing anything to disk. If set to False and there are\n            missing attributes, will likely fail with a KeyError, leading to an incomplete\n            graph written to disk. Defaults to True.\n    \"\"\"\n    if graph.number_of_nodes() == 0:\n        warnings.warn(f\"Graph is empty - not writing anything to {path}\", stacklevel=2)\n        return\n\n    # open/create zarr container\n    if zarr.__version__.startswith(\"3\"):\n        group = zarr.open(path, mode=\"a\", zarr_format=zarr_format)\n    else:\n        group = zarr.open(path, mode=\"a\")\n\n    node_attrs = get_node_attrs(graph)\n    if validate:\n        if position_attr not in node_attrs:\n            raise ValueError(f\"Position attribute {position_attr} not found in graph\")\n        for node, data in graph.nodes(data=True):\n            if position_attr not in data:\n                raise ValueError(f\"Node {node} does not have position attribute {position_attr}\")\n\n    # write metadata\n    roi_min, roi_max = get_roi(graph, position_attr=position_attr)\n    metadata = GeffMetadata(\n        geff_version=geff.__version__,\n        directed=isinstance(graph, nx.DiGraph),\n        roi_min=roi_min,\n        roi_max=roi_max,\n        position_attr=position_attr,\n        axis_names=axis_names if axis_names is not None else graph.graph.get(\"axis_names\", None),\n        axis_units=axis_units if axis_units is not None else graph.graph.get(\"axis_units\", None),\n    )\n    metadata.write(group)\n\n    # get node and edge IDs\n    nodes_list = list(graph.nodes())\n    nodes_arr = np.array(nodes_list)\n    edges_list = list(graph.edges())\n    edges_arr = np.array(edges_list)\n\n    # write nodes\n    group[\"nodes/ids\"] = nodes_arr\n\n    # write node attributes\n    for name in node_attrs:\n        values = []\n        missing = []\n        for node in nodes_list:\n            if name in graph.nodes[node]:\n                value = graph.nodes[node][name]\n                mask = 0\n            else:\n                value = 0\n                mask = 1\n            values.append(value)\n            missing.append(mask)\n        # Set position attribute to default \"position\", original stored in metadata\n        if name == position_attr:\n            name = \"position\"\n        else:\n            # Always store missing array even if all values are present\n            group[f\"nodes/attrs/{name}/missing\"] = np.array(missing, dtype=bool)\n        group[f\"nodes/attrs/{name}/values\"] = np.array(values)\n\n    # write edges\n    # Edge group is only created if edges are present on graph\n    if len(edges_list) &gt; 0:\n        group[\"edges/ids\"] = edges_arr\n\n        # write edge attributes\n        for name in get_edge_attrs(graph):\n            values = []\n            missing = []\n            for edge in edges_list:\n                if name in graph.edges[edge]:\n                    value = graph.edges[edge][name]\n                    mask = 0\n                else:\n                    value = 0\n                    mask = 1\n                values.append(value)\n                missing.append(mask)\n            group[f\"edges/attrs/{name}/missing\"] = np.array(missing, dtype=bool)\n            group[f\"edges/attrs/{name}/values\"] = np.array(values)\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph where every node has a position attribute</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>)           \u2013            <p>the name of the position attribute present on every node</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>the path to the output zarr. Opens in append mode, so will only overwrite geff-controlled groups.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(axis_names)","title":"<code>axis_names</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The names of the spatial dims represented in position attribute. Defaults to None. Will override value in graph attributes if provided.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(axis_units)","title":"<code>axis_units</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The units of the spatial dims represented in position attribute. Defaults to None. Will override value in graph attributes if provided.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Optional[int]</code>, default:                   <code>3</code> )           \u2013            <p>The version of zarr to write. Defaults to 3.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(validate)","title":"<code>validate</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating whether to perform validation on the networkx graph before writing anything to disk. If set to False and there are missing attributes, will likely fail with a KeyError, leading to an incomplete graph written to disk. Defaults to True.</p>"},{"location":"reference/geff/utils/","title":"geff.utils","text":""},{"location":"reference/geff/utils/#geff.utils","title":"geff.utils","text":"<p>Functions:</p> <ul> <li> <code>validate</code>             \u2013              <p>Check that the structure of the zarr conforms to geff specification</p> </li> </ul>"},{"location":"reference/geff/utils/#geff.utils.validate","title":"validate","text":"<pre><code>validate(path: str | Path)\n</code></pre> <p>Check that the structure of the zarr conforms to geff specification</p> <p>Parameters:</p> Source code in <code>src/geff/utils.py</code> <pre><code>def validate(path: str | Path):\n    \"\"\"Check that the structure of the zarr conforms to geff specification\n\n    Args:\n        path (str | Path): Path to geff zarr\n    \"\"\"\n    # Check that directory exists\n    assert os.path.exists(path), f\"Directory {path} does not exist\"\n\n    # zarr python 3 doesn't support Path\n    path = str(path)\n\n    graph = zarr.open(path, mode=\"r\")\n\n    # graph attrs validation\n    # Raises pydantic.ValidationError or ValueError\n    GeffMetadata(**graph.attrs)\n\n    assert \"nodes\" in graph, \"graph group must contain a nodes group\"\n    nodes = graph[\"nodes\"]\n\n    # ids and attrs/position are required and should be same length\n    assert \"ids\" in nodes.array_keys(), \"nodes group must contain an ids array\"\n    assert \"attrs\" in nodes.group_keys(), \"nodes group must contain an attrs group\"\n    assert \"position\" in nodes[\"attrs\"].group_keys(), (\n        \"nodes group must contain an attrs/position group\"\n    )\n    assert \"missing\" not in nodes[\"attrs/position\"].array_keys(), (\n        \"position group cannot have missing values\"\n    )\n\n    # Attribute array length should match id length\n    id_len = nodes[\"ids\"].shape[0]\n    for attr in nodes[\"attrs\"].keys():\n        attr_group = nodes[\"attrs\"][attr]\n        assert \"values\" in attr_group.array_keys(), (\n            f\"node attribute group {attr} must have values group\"\n        )\n        attr_len = attr_group[\"values\"].shape[0]\n        assert attr_len == id_len, (\n            f\"Node attribute {attr} values has length {attr_len}, which does not match \"\n            f\"id length {id_len}\"\n        )\n        if \"missing\" in attr_group.array_keys():\n            missing_len = attr_group[\"missing\"].shape[0]\n            assert missing_len == id_len, (\n                f\"Node attribute {attr} missing mask has length {missing_len}, which \"\n                f\"does not match id length {id_len}\"\n            )\n\n    if \"edges\" in graph.group_keys():\n        edges = graph[\"edges\"]\n\n        # Edges only require ids which contain nodes for each edge\n        assert \"ids\" in edges, \"edge group must contain ids array\"\n        id_shape = edges[\"ids\"].shape\n        assert id_shape[-1] == 2, (\n            f\"edges ids must have a last dimension of size 2, received shape {id_shape}\"\n        )\n\n        # Edge attribute array length should match edge id length\n        edge_id_len = edges[\"ids\"].shape[0]\n        if \"attrs\" in edges:\n            for attr in edges[\"attrs\"].keys():\n                attr_group = edges[\"attrs\"][attr]\n                assert \"values\" in attr_group.array_keys(), (\n                    f\"Edge attribute group {attr} must have values group\"\n                )\n                attr_len = attr_group[\"values\"].shape[0]\n                assert attr_len == edge_id_len, (\n                    f\"Edge attribute {attr} values has length {attr_len}, which does not \"\n                    f\"match id length {edge_id_len}\"\n                )\n                if \"missing\" in attr_group.array_keys():\n                    missing_len = attr_group[\"missing\"].shape[0]\n                    assert missing_len == edge_id_len, (\n                        f\"Edge attribute {attr} missing mask has length {missing_len}, \"\n                        f\"which does not match id length {edge_id_len}\"\n                    )\n</code></pre>"},{"location":"reference/geff/utils/#geff.utils.validate(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>Path to geff zarr</p>"}]}