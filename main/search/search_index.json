{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geff!","text":"<p>geff is a specification for a file format for exchanging spatial graph data. It is not intended to be mutable, editable, chunked, or optimized for use in an application setting.</p> <p>geff is the specification of the file format, but the library also includes implementations for writing from and reading to Python in-memory graph data structures: networkx and spatial_graph. The library uses semantic versioning, where changes to the specification bump the major or minor versions, and bugfixes for the example implementations bump the patch version.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install geff\n</code></pre> <p>To use geff with the <code>spatial-graph</code> backend <pre><code>pip install geff[spatial-graph]\n</code></pre></p> <p>To use geff with the <code>networkx</code> backend <pre><code>pip install geff[networkx]\n</code></pre></p>"},{"location":"specification/","title":"Geff specification","text":"<p>The graph exchange file format is <code>zarr</code> based. A graph is stored in a zarr group, which can have any name. This allows storing multiple <code>geff</code> graphs inside the same zarr root directory. A <code>geff</code> group is identified by the presence of a <code>geff_version</code> attribute in the <code>.zattrs</code>. Other <code>geff</code> metadata is also stored in the <code>.zattrs</code> file of the <code>geff</code> group. The <code>geff</code> group must contain a <code>nodes</code> group and an <code>edges</code> group.</p>"},{"location":"specification/#geff-metadata","title":"Geff metadata geff_version Required  directed Required  roi_min Required  roi_max Required  position_attr  axis_names  Any of  axis_units  Any of","text":"geff_metadata geff_metadataType: object <p>Geff metadata schema to validate the attributes json file in a geff zarr</p> root          geff_versionGeff VersionType: string Must match regular expression: <code>(0\\.0)</code> root          directedDirectedType: boolean root          roi_minRoi MinType: array of number No Additional ItemsEach item of this array must be: root          roi_min roi_min itemsType: number root          roi_maxRoi MaxType: array of number No Additional ItemsEach item of this array must be: root          roi_max roi_max itemsType: number root          position_attrPosition AttrType: string Default: \"position\" root          axis_namesAxis Names Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          axis_names anyOf item 0Type: array of string No Additional ItemsEach item of this array must be: root          axis_names anyOf item 0 item 0 itemsType: string root          axis_names anyOf item 1Type: null root          axis_unitsAxis Units Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          axis_units anyOf item 0Type: array of string No Additional ItemsEach item of this array must be: root          axis_units anyOf item 0 item 0 itemsType: string root          axis_units anyOf item 1Type: null <p>Generated using json-schema-for-humans on 2025-04-11 at 19:25:47 +0000</p>"},{"location":"specification/#the-nodes-group","title":"The <code>nodes</code> group","text":"<p>The nodes group will contain an <code>ids</code> array and an <code>attrs</code> group.</p>"},{"location":"specification/#the-ids-array","title":"The <code>ids</code> array","text":"<p>The <code>nodes\\ids</code> array is a 1D array of node IDs of length <code>N</code> &gt; 0, where <code>N</code> is the number of nodes in the graph. Node ids must be unique. Node IDs can have any type supported by zarr, but we recommend integer dtypes. For large graphs, <code>uint64</code> might be necessary to provide enough range for every node to have a unique ID. </p>"},{"location":"specification/#the-attrs-group-and-node-attribute-groups","title":"The <code>attrs</code> group and <code>node attribute</code> groups","text":"<p>The <code>nodes\\attrs</code> group will contain one or more <code>node attribute</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array. </p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the node <code>ids</code> array, such that each row of the attribute <code>values</code> array stores the attribute for the node at that index in the ids array. </li> <li>The <code>missing</code> array is an optional, a one dimensional boolean array to support attributes that are not present on all nodes. A 1 at an index in the <code>missing</code> array indicates that the <code>value</code> of that attribute for the node at that index is None, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all nodes have values for the attribute. </li> </ul> <p>Note</p> <p>When writing a graph with missing attributes to the geff format, you must fill in a dummy value in the <code>values</code> array for the nodes that are missing the attribute, in order to keep the indices aligned with the node ids.</p> <ul> <li>The <code>position</code> group is a special node attribute group that must be present and does not allow missing attributes.</li> <li>The <code>seg_id</code> group is an optional, special node attribute group that stores the segmenatation label for each node. The <code>seg_id</code> values do not need to be unique, in case labels are repeated between time points. If the <code>seg_id</code> group is not present, it is assumed that the graph is not associated with a segmentation. </li> </ul>"},{"location":"specification/#the-edges-group","title":"The <code>edges</code> group","text":"<p>Similar to the <code>nodes</code> group, the <code>edges</code> group will contain an <code>ids</code> array and an <code>attrs</code> group. If there are no edges in the graph, the edge group is not created.</p>"},{"location":"specification/#the-ids-array_1","title":"The <code>ids</code> array","text":"<p>The <code>edges\\ids</code> array is a 2D array with the same dtype as the <code>nodes\\ids</code> array. It has shape <code>(2, E)</code>, where <code>E</code> is the number of edges in the graph. All elements in the <code>edges\\ids</code> array must also be present in the <code>nodes\\ids</code> array. Each row represents an edge between two nodes. For directed graphs, the first column is the source nodes and the second column holds the target nodes. For undirected graphs, the order is arbitrary. Edges should be unique (no multiple edges between the same two nodes) and edges from a node to itself are not supported.</p>"},{"location":"specification/#the-attrs-group-and-edge-attribute-groups","title":"The <code>attrs</code> group and <code>edge attribute</code> groups","text":"<p>The <code>edges\\attrs</code> group will contain zero or more <code>edge attribute</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array. </p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the <code>edges\\ids</code> array, such that each row of the attribute <code>values</code> array stores the attribute for the edge at that index in the ids array. </li> <li>The <code>missing</code> array is an optional, a one dimensional boolean array to support attributes that are not present on all edges. A 1 at an index in the <code>missing</code> array indicates that the <code>value</code> of that attribute for the edge at that index is missing, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all edges have values for the attribute.</li> </ul> <p>If you do not have any edge attributes, the <code>edges\\attrs</code> group should still be present, but empty.</p>"},{"location":"specification/#example-file-structure-and-metadata","title":"Example file structure and metadata","text":"<p>TODO: Example metadata for this file structure <pre><code>/path/to.zarr\n    /tracking_graph\n        .zattrs  # graph metadata with `geff_version`\n        nodes/\n            ids  # shape: (N,)  dtype: uint64\n            attrs/\n                position/\n                    values # shape: (N, 3) dtype: float16\n                color/\n                    values # shape: (N, 4) dtype: float16\n                    missing # shape: (N,) dtype: bool\n        edges/\n            ids  # shape: (E, 2) dtype: uint64\n            attrs/\n                distance/\n                    values # shape: (E,) dtype: float16\n                score/\n                    values # shape: (E,) dtype: float16\n                    missing # shape: (E,) dtype: bool\n    # optional:\n    /segmentation \n\n    # unspecified, but totally okay:\n    /raw \n</code></pre></p>"},{"location":"what-is-geff/","title":"What is geff?","text":"<p><code>geff</code> is a graph exchange file format that seeks to fulfill the following needs: - Provide a storage/exchange format for graphs and optional segmentation - Provide a common API with reference implementations for use in other projects</p>"},{"location":"what-is-geff/#design-decisions-and-assumptions","title":"Design Decisions and Assumptions","text":"<ul> <li>Raw image data is not included in the <code>geff</code> spec. However, to keep nodes linked to segmentation labels, support for specifying the seg_id of each node in a standard way, along with the path to the segmentation, are included in the <code>spec</code>.</li> <li>Since <code>geff</code> is an exchange format, we do not provide support for searching or filtering.</li> <li>We do not provide support for editing or changing the graph on the fly.</li> <li>In order to support efficient reading/writing, we assume the graph can fit into memory.</li> </ul>"},{"location":"reference/geff/","title":"geff","text":""},{"location":"reference/geff/#geff","title":"geff","text":"<p>Modules:</p> <ul> <li> <code>metadata_schema</code>           \u2013            </li> <li> <code>networkx</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/geff/metadata_schema/","title":"geff.metadata_schema","text":""},{"location":"reference/geff/metadata_schema/#geff.metadata_schema","title":"geff.metadata_schema","text":"<p>Classes:</p> <ul> <li> <code>GeffMetadata</code>           \u2013            <p>Geff metadata schema to validate the attributes json file in a geff zarr</p> </li> </ul>"},{"location":"reference/geff/metadata_schema/#geff.metadata_schema.GeffMetadata","title":"GeffMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geff metadata schema to validate the attributes json file in a geff zarr</p>"},{"location":"reference/geff/networkx/","title":"geff.networkx","text":""},{"location":"reference/geff/networkx/#geff.networkx","title":"geff.networkx","text":"<p>Modules:</p> <ul> <li> <code>io</code>           \u2013            </li> </ul>"},{"location":"reference/geff/networkx/io/","title":"geff.networkx.io","text":""},{"location":"reference/geff/networkx/io/#geff.networkx.io","title":"geff.networkx.io","text":"<p>Functions:</p> <ul> <li> <code>get_edge_attrs</code>             \u2013              <p>Get the attribute keys present on any edge in the networkx graph. Does not imply</p> </li> <li> <code>get_node_attrs</code>             \u2013              <p>Get the attribute keys present on any node in the networkx graph. Does not imply</p> </li> <li> <code>get_roi</code>             \u2013              <p>Get the roi of a networkx graph.</p> </li> <li> <code>read</code>             \u2013              <p>Read a geff file into a networkx graph.</p> </li> <li> <code>write</code>             \u2013              <p>Write a networkx graph to the geff file format</p> </li> </ul>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_edge_attrs","title":"get_edge_attrs","text":"<pre><code>get_edge_attrs(graph: Graph) -&gt; list[str]\n</code></pre> <p>Get the attribute keys present on any edge in the networkx graph. Does not imply that the attributes are present on all edges.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all unique edge attribute keys</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_edge_attrs(graph: nx.Graph) -&gt; list[str]:\n    \"\"\"Get the attribute keys present on any edge in the networkx graph. Does not imply\n    that the attributes are present on all edges.\n\n    Args:\n        graph (nx.Graph): a networkx graph\n\n    Returns:\n        list[str]: A list of all unique edge attribute keys\n    \"\"\"\n    return list({k for e in graph.edges for k in graph.edges[e]})\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_node_attrs","title":"get_node_attrs","text":"<pre><code>get_node_attrs(graph: Graph) -&gt; list[str]\n</code></pre> <p>Get the attribute keys present on any node in the networkx graph. Does not imply that the attributes are present on all nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all unique node attribute keys</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_node_attrs(graph: nx.Graph) -&gt; list[str]:\n    \"\"\"Get the attribute keys present on any node in the networkx graph. Does not imply\n    that the attributes are present on all nodes.\n\n    Args:\n        graph (nx.Graph): a networkx graph\n\n    Returns:\n        list[str]: A list of all unique node attribute keys\n    \"\"\"\n    return list({k for n in graph.nodes for k in graph.nodes[n]})\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi","title":"get_roi","text":"<pre><code>get_roi(graph: Graph, position_attr: str) -&gt; tuple[tuple[float, ...], tuple[float, ...]]\n</code></pre> <p>Get the roi of a networkx graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[tuple[float, ...], tuple[float, ...]]</code>           \u2013            <p>tuple[tuple[float, ...], tuple[float, ...]]: A tuple with the min values in each spatial dim, and a tuple with the max values in each spatial dim</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_roi(graph: nx.Graph, position_attr: str) -&gt; tuple[tuple[float, ...], tuple[float, ...]]:\n    \"\"\"Get the roi of a networkx graph.\n\n    Args:\n        graph (nx.Graph): A non-empty networkx graph\n        position_attr (str): All nodes on graph have this attribute holding their position\n\n    Returns:\n        tuple[tuple[float, ...], tuple[float, ...]]: A tuple with the min values in each\n            spatial dim, and a tuple with the max values in each spatial dim\n    \"\"\"\n    _min = None\n    _max = None\n    for _, data in graph.nodes(data=True):\n        pos = np.array(data[position_attr])\n        if _min is None:\n            _min = pos\n            _max = pos\n        else:\n            _min = np.min([_min, pos], axis=0)\n            _max = np.max([_max, pos], axis=0)\n\n    return tuple(_min.tolist()), tuple(_max.tolist())  # type: ignore\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>A non-empty networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>)           \u2013            <p>All nodes on graph have this attribute holding their position</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.read","title":"read","text":"<pre><code>read(path: Path | str, validate: bool = True) -&gt; nx.Graph\n</code></pre> <p>Read a geff file into a networkx graph.</p> <p>Parameters:</p> <p>Returns:     nx.Graph: The graph that was stored in the geff file format</p> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def read(path: Path | str, validate: bool = True) -&gt; nx.Graph:\n    \"\"\"Read a geff file into a networkx graph.\n\n    Args:\n        path (Path): The path to the root of the geff zarr, where the .attrs contains\n            the geff  metadata\n    Returns:\n        nx.Graph: The graph that was stored in the geff file format\n    \"\"\"\n    # open zarr container\n    if validate:\n        geff.utils.validate(path)\n\n    group = zarr.open(path, \"r\")\n    metadata = GeffMetadata(**group.attrs)\n\n    # read meta-data\n    graph = nx.DiGraph() if metadata.directed else nx.Graph()\n\n    nodes = group[\"nodes/ids\"][:]\n    graph.add_nodes_from(nodes.tolist())\n    edges = group[\"edges/ids\"][:]\n    graph.add_edges_from(edges.tolist())\n\n    # collect node attributes\n    for name in group[\"nodes/attrs\"]:\n        ds = group[f\"nodes/attrs/{name}\"]\n        for node, val in zip(nodes, ds[:]):\n            val = val.tolist() if val.size &gt; 1 else val.item()\n            graph.nodes[node.item()][name] = val\n\n    # collect edge attributes]\n    for name in group[\"edges/attrs\"]:\n        ds = group[f\"edges/attrs/{name}\"]\n        for edge, val in zip(edges, ds[:]):\n            val = val.tolist() if val.size &gt; 1 else val.item()\n            source, target = edge.tolist()\n            graph.edges[source, target][name] = val\n\n    return graph\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.read(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>The path to the root of the geff zarr, where the .attrs contains the geff  metadata</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write","title":"write","text":"<pre><code>write(graph: Graph, position_attr: str, path: str | Path, axis_names: list[str] | None = None, axis_units: list[str] | None = None)\n</code></pre> <p>Write a networkx graph to the geff file format</p> <p>Parameters:</p> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def write(\n    graph: nx.Graph,\n    position_attr: str,\n    path: str | Path,\n    axis_names: list[str] | None = None,\n    axis_units: list[str] | None = None,\n):\n    \"\"\"Write a networkx graph to the geff file format\n\n    Args:\n        graph (nx.Graph): a networkx graph where every node has a position attribute\n        position_attr (str): the name of the position attribute present on every node\n        path (str | Path): the path to the output zarr. Opens in append mode,\n            so will only overwrite geff-controlled groups.\n        axis_names (Optional[list[str]], optional): The names of the spatial dims\n            represented in position attribute. Defaults to None.\n        axis_units (Optional[list[str]], optional): The units of the spatial dims\n            represented in position attribute. Defaults to None.\n    \"\"\"\n    if nx.is_empty(graph):\n        warnings.warn(f\"Graph is empty - not writing anything to {path}\", stacklevel=2)\n        return\n    # open/create zarr container\n    group = zarr.open(path, \"a\")\n\n    # write meta-datajj\n    group.attrs[\"geff_version\"] = geff.__version__\n    group.attrs[\"position_attr\"] = position_attr\n    group.attrs[\"directed\"] = isinstance(graph, nx.DiGraph)\n    roi_min, roi_max = get_roi(graph, position_attr=position_attr)\n    group.attrs[\"roi_min\"] = roi_min\n    group.attrs[\"roi_max\"] = roi_max\n    if axis_names:\n        graph.attrs[\"axis_names\"] = axis_names\n    if axis_units:\n        graph.attrs[\"axis_units\"] = axis_units\n\n    # get node and edge IDs\n    nodes_list = list(graph.nodes())\n    nodes_arr = np.array(nodes_list)\n    edges_list = list(graph.edges())\n    edges_arr = np.array(edges_list)\n\n    # write nodes\n    group[\"nodes/ids\"] = nodes_arr\n\n    # write node attributes\n    for name in get_node_attrs(graph):\n        # TODO: handle missing values\n        group[f\"nodes/attrs/{name}\"] = np.array([graph.nodes[node][name] for node in nodes_list])\n\n    # write edges\n    group[\"edges/ids\"] = edges_arr\n\n    # write edge attributes\n    for name in get_edge_attrs(graph):\n        group[f\"edges/attrs/{name}\"] = np.array([graph.edges[edge][name] for edge in edges_list])\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph where every node has a position attribute</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>)           \u2013            <p>the name of the position attribute present on every node</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>the path to the output zarr. Opens in append mode, so will only overwrite geff-controlled groups.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(axis_names)","title":"<code>axis_names</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The names of the spatial dims represented in position attribute. Defaults to None.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(axis_units)","title":"<code>axis_units</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The units of the spatial dims represented in position attribute. Defaults to None.</p>"},{"location":"reference/geff/spatial_graph/","title":"geff.spatial_graph","text":""},{"location":"reference/geff/spatial_graph/#geff.spatial_graph","title":"geff.spatial_graph","text":""},{"location":"reference/geff/spatial_graph/io/","title":"geff.spatial_graph.io","text":""},{"location":"reference/geff/spatial_graph/io/#geff.spatial_graph.io","title":"geff.spatial_graph.io","text":""},{"location":"reference/geff/utils/","title":"geff.utils","text":""},{"location":"reference/geff/utils/#geff.utils","title":"geff.utils","text":"<p>Functions:</p> <ul> <li> <code>validate</code>             \u2013              <p>Check that the structure of the zarr conforms to geff specification</p> </li> </ul>"},{"location":"reference/geff/utils/#geff.utils.validate","title":"validate","text":"<pre><code>validate(path: str | Path)\n</code></pre> <p>Check that the structure of the zarr conforms to geff specification</p> <p>Parameters:</p> Source code in <code>src/geff/utils.py</code> <pre><code>def validate(path: str | Path):\n    \"\"\"Check that the structure of the zarr conforms to geff specification\n\n    Args:\n        path (str | Path): Path to geff zarr\n    \"\"\"\n    # Check that directory exists\n    assert os.path.exists(path), f\"Directory {path} does not exist\"\n\n    graph = zarr.open(path, mode=\"r\")\n\n    # graph attrs validation\n    # Raises pydantic.ValidationError or ValueError\n    GeffMetadata(**graph.attrs)\n\n    assert \"nodes\" in graph, \"graph group must contain a nodes group\"\n    nodes = graph[\"nodes\"]\n\n    # ids and attrs/position are required and should be same length\n    assert \"ids\" in nodes, \"nodes group must contain an ids array\"\n    assert \"attrs/position\" in nodes, \"nodes group must contain an attrs/position array\"\n\n    # Attribute array length should match id length\n    for attr in nodes[\"attrs\"].keys():\n        attr_len = nodes[\"attrs\"][attr].shape[0]\n        id_len = nodes[\"ids\"].shape[0]\n        assert attr_len == id_len, (\n            f\"Node attribute {attr} has length {attr_len}, which does not match id length {id_len}\"\n        )\n\n    assert \"edges\" in graph, \"graph group must contain an edge group\"\n    edges = graph[\"edges\"]\n\n    # Edges only require ids which contain nodes for each edge\n    assert \"ids\" in edges, \"edge group must contain ids array\"\n    id_shape = edges[\"ids\"].shape\n    assert id_shape[-1] == 2, (\n        f\"edges ids must have a last dimension of size 2, received shape {id_shape}\"\n    )\n</code></pre>"},{"location":"reference/geff/utils/#geff.utils.validate(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>Path to geff zarr</p>"}]}