{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geff!","text":"<p>geff is a specification for a file format for exchanging spatial graph data. It is not intended to be mutable, editable, chunked, or optimized for use in an application setting.</p> <p>geff is the specification of the file format, but the library also includes implementations for writing from and reading to a networkx graph, a common Python in-memory graph data structure. The library uses semantic versioning, where changes to the specification bump the major or minor versions, and bugfixes for the example implementation bumps the patch version.</p> <p>Learn more in the documentation or check out the source code.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install geff\n</code></pre>"},{"location":"api/","title":"API Docs","text":""},{"location":"api/#networkx-backend","title":"Networkx Backend","text":""},{"location":"api/#geff.read_nx","title":"geff.read_nx","text":"<pre><code>read_nx(\n    path: Path | str, validate: bool = True\n) -&gt; nx.Graph\n</code></pre> <p>Read a geff file into a networkx graph. Metadata attributes will be stored in the graph attributes, accessed via <code>G.graph[key]</code> where G is a networkx graph.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the root of the geff zarr, where the .attrs contains the geff  metadata</p> required <code>validate</code> <code>bool</code> <p>Flag indicating whether to perform validation on the geff file before loading into memory. If set to False and there are format issues, will likely fail with a cryptic error. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Graph</code> <p>A networkx graph containing the graph that was stored in the geff file format</p>"},{"location":"api/#geff.write_nx","title":"geff.write_nx","text":"<pre><code>write_nx(\n    graph: Graph,\n    path: str | Path,\n    position_attr: str | None = None,\n    axis_names: list[str] | None = None,\n    axis_units: list[str] | None = None,\n    zarr_format: int = 2,\n    validate: bool = True,\n)\n</code></pre> <p>Write a networkx graph to the geff file format</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>A networkx graph</p> required <code>path</code> <code>str | Path</code> <p>The path to the output zarr. Opens in append mode, so will only overwrite geff-controlled groups.</p> required <code>position_attr</code> <code>Optional[str]</code> <p>The name of the position attribute present on every node, if present. Defaults to None.</p> <code>None</code> <code>axis_names</code> <code>Optional[list[str]]</code> <p>The names of the spatial dims represented in position attribute. Defaults to None. Will override value in graph attributes if provided.</p> <code>None</code> <code>axis_units</code> <code>Optional[list[str]]</code> <p>The units of the spatial dims represented in position attribute. Defaults to None. Will override value in graph attributes if provided.</p> <code>None</code> <code>zarr_format</code> <code>int</code> <p>The version of zarr to write. Defaults to 2.</p> <code>2</code> <code>validate</code> <code>bool</code> <p>Flag indicating whether to perform validation on the networkx graph before writing anything to disk. If set to False and there are missing attributes, will likely fail with a KeyError, leading to an incomplete graph written to disk. Defaults to True.</p> <code>True</code>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#geff.validate","title":"geff.validate","text":"<pre><code>validate(path: str | Path)\n</code></pre> <p>Check that the structure of the zarr conforms to geff specification</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to geff zarr</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If geff specs are violated</p>"},{"location":"api/#geff.GeffMetadata","title":"geff.GeffMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geff metadata schema to validate the attributes json file in a geff zarr</p>"},{"location":"api/#geff.GeffMetadata.read","title":"read  <code>classmethod</code>","text":"<pre><code>read(group: Group | Path) -&gt; GeffMetadata\n</code></pre> <p>Helper function to read GeffMetadata from a zarr geff group.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>Group | Path</code> <p>The zarr group containing the geff metadata</p> required <p>Returns:</p> Name Type Description <code>GeffMetadata</code> <code>GeffMetadata</code> <p>The GeffMetadata object</p>"},{"location":"api/#geff.GeffMetadata.write","title":"write","text":"<pre><code>write(group: Group | Path)\n</code></pre> <p>Helper function to write GeffMetadata into the zarr geff group.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>Group | Path</code> <p>The geff group to write the metadata to</p> required"},{"location":"specification/","title":"Geff specification","text":"<p>The graph exchange file format is <code>zarr</code> based. A graph is stored in a zarr group, which can have any name. This allows storing multiple <code>geff</code> graphs inside the same zarr root directory. A <code>geff</code> group is identified by the presence of a <code>geff_version</code> attribute in the <code>.zattrs</code>. Other <code>geff</code> metadata is also stored in the <code>.zattrs</code> file of the <code>geff</code> group. The <code>geff</code> group must contain a <code>nodes</code> group and an <code>edges</code> group.</p> <p><code>geff</code> graphs have the option to provide position as a special attribute. In this case, a <code>position_attr</code> must be specified in the <code>geff</code> metadata along with a <code>roi_min</code> and <code>roi_max</code>. If a <code>position_attr</code> is provided, every node must have a position value.</p>"},{"location":"specification/#zarr-specification","title":"Zarr specification","text":"<p>Currently, <code>geff</code> supports zarr specifications 2 and 3. However, <code>geff</code> will default to writing specification 2 because graphs written to the zarr v3 spec will not be compatible with all applications. When zarr 3 is more fully adopted by other libraries and tools, we will move to a zarr spec 3 default.</p>"},{"location":"specification/#geff-metadata","title":"Geff metadata geff_version Required  directed Required  roi_min  Any of  roi_max  Any of  position_attr  Any of  axis_names  Any of  axis_units  Any of","text":"geff_metadata geff_metadataType: object <p>Geff metadata schema to validate the attributes json file in a geff zarr</p> root          geff_versionGeff VersionType: string Must match regular expression: <code>(0\\.0)|(0\\.1)|(0\\.2)</code> root          directedDirectedType: boolean root          roi_minRoi Min Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          roi_min anyOf item 0Type: array of number No Additional ItemsEach item of this array must be: root          roi_min anyOf item 0 item 0 itemsType: number root          roi_min anyOf item 1Type: null root          roi_maxRoi Max Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          roi_max anyOf item 0Type: array of number No Additional ItemsEach item of this array must be: root          roi_max anyOf item 0 item 0 itemsType: number root          roi_max anyOf item 1Type: null root          position_attrPosition Attr Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          position_attr anyOf item 0Type: string root          position_attr anyOf item 1Type: null root          axis_namesAxis Names Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          axis_names anyOf item 0Type: array of string No Additional ItemsEach item of this array must be: root          axis_names anyOf item 0 item 0 itemsType: string root          axis_names anyOf item 1Type: null root          axis_unitsAxis Units Default: null <ul><li> Option 1 </li><li> Option 2 </li></ul> root          axis_units anyOf item 0Type: array of string No Additional ItemsEach item of this array must be: root          axis_units anyOf item 0 item 0 itemsType: string root          axis_units anyOf item 1Type: null <p>Generated using json-schema-for-humans on 2025-07-17 at 15:19:51 +0000</p>"},{"location":"specification/#the-nodes-group","title":"The <code>nodes</code> group","text":"<p>The nodes group will contain an <code>ids</code> array and an <code>attrs</code> group.</p>"},{"location":"specification/#the-ids-array","title":"The <code>ids</code> array","text":"<p>The <code>nodes\\ids</code> array is a 1D array of node IDs of length <code>N</code> &gt; 0, where <code>N</code> is the number of nodes in the graph. Node ids must be unique. Node IDs can have any type supported by zarr, but we recommend integer dtypes. For large graphs, <code>uint64</code> might be necessary to provide enough range for every node to have a unique ID. </p>"},{"location":"specification/#the-attrs-group-and-node-attribute-groups","title":"The <code>attrs</code> group and <code>node attribute</code> groups","text":"<p>The <code>nodes\\attrs</code> group will contain one or more <code>node attribute</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array. </p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the node <code>ids</code> array, such that each row of the attribute <code>values</code> array stores the attribute for the node at that index in the ids array. </li> <li>The <code>missing</code> array is an optional, a one dimensional boolean array to support attributes that are not present on all nodes. A 1 at an index in the <code>missing</code> array indicates that the <code>value</code> of that attribute for the node at that index is None, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all nodes have values for the attribute. </li> </ul> <p>Note</p> <p>When writing a graph with missing attributes to the geff format, you must fill in a dummy value in the <code>values</code> array for the nodes that are missing the attribute, in order to keep the indices aligned with the node ids.</p> <ul> <li>The <code>position</code> group is a special node attribute group that must be present if a <code>position_attr</code> is set in the <code>geff</code> metadata and does not allow missing attributes.</li> <li>The <code>seg_id</code> group is an optional, special node attribute group that stores the segmenatation label for each node. The <code>seg_id</code> values do not need to be unique, in case labels are repeated between time points. If the <code>seg_id</code> group is not present, it is assumed that the graph is not associated with a segmentation. </li> </ul>"},{"location":"specification/#the-edges-group","title":"The <code>edges</code> group","text":"<p>Similar to the <code>nodes</code> group, the <code>edges</code> group will contain an <code>ids</code> array and an <code>attrs</code> group. If there are no edges in the graph, the edge group is not created.</p>"},{"location":"specification/#the-ids-array_1","title":"The <code>ids</code> array","text":"<p>The <code>edges\\ids</code> array is a 2D array with the same dtype as the <code>nodes\\ids</code> array. It has shape <code>(2, E)</code>, where <code>E</code> is the number of edges in the graph. All elements in the <code>edges\\ids</code> array must also be present in the <code>nodes\\ids</code> array. Each row represents an edge between two nodes. For directed graphs, the first column is the source nodes and the second column holds the target nodes. For undirected graphs, the order is arbitrary. Edges should be unique (no multiple edges between the same two nodes) and edges from a node to itself are not supported.</p>"},{"location":"specification/#the-attrs-group-and-edge-attribute-groups","title":"The <code>attrs</code> group and <code>edge attribute</code> groups","text":"<p>The <code>edges\\attrs</code> group will contain zero or more <code>edge attribute</code> groups, each with a <code>values</code> array and an optional <code>missing</code> array. </p> <ul> <li><code>values</code> arrays can be any zarr supported dtype, and can be N-dimensional. The first dimension of the <code>values</code> array must have the same length as the <code>edges\\ids</code> array, such that each row of the attribute <code>values</code> array stores the attribute for the edge at that index in the ids array. </li> <li>The <code>missing</code> array is an optional, a one dimensional boolean array to support attributes that are not present on all edges. A 1 at an index in the <code>missing</code> array indicates that the <code>value</code> of that attribute for the edge at that index is missing, and the value in the <code>values</code> array at that index should be ignored. If the <code>missing</code> array is not present, that means that all edges have values for the attribute.</li> </ul> <p>If you do not have any edge attributes, the <code>edges\\attrs</code> group should still be present, but empty.</p>"},{"location":"specification/#example-file-structure-and-metadata","title":"Example file structure and metadata","text":"<p>Here is a schematic of the expected file structure. <pre><code>/path/to.zarr\n    /tracking_graph\n        .zattrs  # graph metadata with `geff_version`\n        nodes/\n            ids  # shape: (N,)  dtype: uint64\n            attrs/\n                position/\n                    values # shape: (N, 3) dtype: float16\n                color/\n                    values # shape: (N, 4) dtype: float16\n                    missing # shape: (N,) dtype: bool\n        edges/\n            ids  # shape: (E, 2) dtype: uint64\n            attrs/\n                distance/\n                    values # shape: (E,) dtype: float16\n                score/\n                    values # shape: (E,) dtype: float16\n                    missing # shape: (E,) dtype: bool\n    # optional:\n    /segmentation \n\n    # unspecified, but totally okay:\n    /raw \n</code></pre> This is a geff metadata zattrs file that matches the above example structure. <pre><code># /path/to.zarr/tracking_graph/.zattrs\n{\n    \"axis_names\": [ # optional\n        \"z\",\n        \"y\",\n        \"x\"\n    ],\n    \"axis_units\": [ # optional\n        \"um\",\n        \"um\",\n        \"um\"\n    ],\n    \"directed\": true,\n    \"geff_version\": \"0.1.3.dev4+gd5d1132.d20250616\",\n    \"position_attr\": \"position\",\n    \"roi_max\": [ # Required if position_attr is specified\n        4398.1,\n        1877.7,\n        2152.3\n    ],\n    \"roi_min\": [ # Required if position_attr is specified\n        1523.368197,\n        81.667,\n        764.42\n    ],\n    ... # custom other things are allowed and ignored by geff\n}\n</code></pre></p>"},{"location":"what-is-geff/","title":"What is geff?","text":"<p><code>geff</code> is a graph exchange file format that seeks to fulfill the following needs:</p> <ul> <li>Provide a storage/exchange format for graphs and optional segmentation</li> <li>Provide a common API with reference implementations for use in other projects</li> </ul>"},{"location":"what-is-geff/#design-decisions-and-assumptions","title":"Design Decisions and Assumptions","text":"<ul> <li>Raw image data is not included in the <code>geff</code> spec. However, to keep nodes linked to segmentation labels, support for specifying the seg_id of each node in a standard way, along with the path to the segmentation, are included in the <code>spec</code>.</li> <li>Since <code>geff</code> is an exchange format, we do not provide support for searching or filtering.</li> <li>We do not provide support for editing or changing the graph on the fly.</li> <li>In order to support efficient reading/writing, we assume the graph can fit into memory.</li> </ul>"}]}