{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geff!","text":"<p>geff is a specification for a file format for exchanging spatial graph data. It is not intended to be mutable, editable, chunked, or optimized for use in an application setting.</p> <p>geff is the specification of the file format, but the library also includes implementations for writing from and reading to Python in-memory graph data structures: networkx and spatial_graph. The library uses semantic versioning, where changes to the specification bump the major or minor versions, and bugfixes for the example implementations bump the patch version.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install geff\n</code></pre> <p>To use geff with the <code>spatial-graph</code> backend</p> <pre><code>pip install geff[spatial-graph]\n</code></pre> <p>To use geff with the <code>networkx</code> backend</p> <pre><code>pip install geff[networkx]\n</code></pre>"},{"location":"reference/geff/","title":"geff","text":""},{"location":"reference/geff/#geff","title":"geff","text":"<p>Modules:</p> <ul> <li> <code>metadata_schema</code>           \u2013            </li> <li> <code>networkx</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/geff/metadata_schema/","title":"geff.metadata_schema","text":""},{"location":"reference/geff/metadata_schema/#geff.metadata_schema","title":"geff.metadata_schema","text":"<p>Classes:</p> <ul> <li> <code>GeffMetadata</code>           \u2013            <p>Geff metadata schema to validate the attributes json file in a geff zarr</p> </li> </ul>"},{"location":"reference/geff/metadata_schema/#geff.metadata_schema.GeffMetadata","title":"GeffMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geff metadata schema to validate the attributes json file in a geff zarr</p>"},{"location":"reference/geff/networkx/","title":"geff.networkx","text":""},{"location":"reference/geff/networkx/#geff.networkx","title":"geff.networkx","text":"<p>Modules:</p> <ul> <li> <code>io</code>           \u2013            </li> </ul>"},{"location":"reference/geff/networkx/io/","title":"geff.networkx.io","text":""},{"location":"reference/geff/networkx/io/#geff.networkx.io","title":"geff.networkx.io","text":"<p>Functions:</p> <ul> <li> <code>get_edge_attrs</code>             \u2013              <p>Get the attribute keys present on any edge in the networkx graph. Does not imply</p> </li> <li> <code>get_node_attrs</code>             \u2013              <p>Get the attribute keys present on any node in the networkx graph. Does not imply</p> </li> <li> <code>get_roi</code>             \u2013              <p>Get the roi of a networkx graph.</p> </li> <li> <code>read</code>             \u2013              <p>Read a geff file into a networkx graph.</p> </li> <li> <code>write</code>             \u2013              <p>Write a networkx graph to the geff file format</p> </li> </ul>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_edge_attrs","title":"get_edge_attrs","text":"<pre><code>get_edge_attrs(graph: Graph) -&gt; list[str]\n</code></pre> <p>Get the attribute keys present on any edge in the networkx graph. Does not imply that the attributes are present on all edges.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all unique edge attribute keys</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_edge_attrs(graph: nx.Graph) -&gt; list[str]:\n    \"\"\"Get the attribute keys present on any edge in the networkx graph. Does not imply\n    that the attributes are present on all edges.\n\n    Args:\n        graph (nx.Graph): a networkx graph\n\n    Returns:\n        list[str]: A list of all unique edge attribute keys\n    \"\"\"\n    return list({k for e in graph.edges for k in graph.edges[e]})\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_node_attrs","title":"get_node_attrs","text":"<pre><code>get_node_attrs(graph: Graph) -&gt; list[str]\n</code></pre> <p>Get the attribute keys present on any node in the networkx graph. Does not imply that the attributes are present on all nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all unique node attribute keys</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_node_attrs(graph: nx.Graph) -&gt; list[str]:\n    \"\"\"Get the attribute keys present on any node in the networkx graph. Does not imply\n    that the attributes are present on all nodes.\n\n    Args:\n        graph (nx.Graph): a networkx graph\n\n    Returns:\n        list[str]: A list of all unique node attribute keys\n    \"\"\"\n    return list({k for n in graph.nodes for k in graph.nodes[n]})\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi","title":"get_roi","text":"<pre><code>get_roi(graph: Graph, position_attr: str) -&gt; tuple[tuple[float, ...], tuple[float, ...]]\n</code></pre> <p>Get the roi of a networkx graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[tuple[float, ...], tuple[float, ...]]</code>           \u2013            <p>tuple[tuple[float, ...], tuple[float, ...]]: A tuple with the min values in each spatial dim, and a tuple with the max values in each spatial dim</p> </li> </ul> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def get_roi(graph: nx.Graph, position_attr: str) -&gt; tuple[tuple[float, ...], tuple[float, ...]]:\n    \"\"\"Get the roi of a networkx graph.\n\n    Args:\n        graph (nx.Graph): A non-empty networkx graph\n        position_attr (str): All nodes on graph have this attribute holding their position\n\n    Returns:\n        tuple[tuple[float, ...], tuple[float, ...]]: A tuple with the min values in each\n            spatial dim, and a tuple with the max values in each spatial dim\n    \"\"\"\n    _min = None\n    _max = None\n    for _, data in graph.nodes(data=True):\n        pos = np.array(data[position_attr])\n        if _min is None:\n            _min = pos\n            _max = pos\n        else:\n            _min = np.min([_min, pos], axis=0)\n            _max = np.max([_max, pos], axis=0)\n\n    return tuple(_min.tolist()), tuple(_max.tolist())  # type: ignore\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>A non-empty networkx graph</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.get_roi(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>)           \u2013            <p>All nodes on graph have this attribute holding their position</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.read","title":"read","text":"<pre><code>read(path: Path | str, validate: bool = True) -&gt; nx.Graph\n</code></pre> <p>Read a geff file into a networkx graph.</p> <p>Parameters:</p> <p>Returns:     nx.Graph: The graph that was stored in the geff file format</p> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def read(path: Path | str, validate: bool = True) -&gt; nx.Graph:\n    \"\"\"Read a geff file into a networkx graph.\n\n    Args:\n        path (Path): The path to the root of the geff zarr, where the .attrs contains\n            the geff  metadata\n    Returns:\n        nx.Graph: The graph that was stored in the geff file format\n    \"\"\"\n    # open zarr container\n    if validate:\n        geff.utils.validate(path)\n\n    group = zarr.open(path, \"r\")\n    metadata = GeffMetadata(**group.attrs)\n\n    # read meta-data\n    graph = nx.DiGraph() if metadata.directed else nx.Graph()\n\n    nodes = group[\"nodes/ids\"][:]\n    graph.add_nodes_from(nodes.tolist())\n    edges = group[\"edges/ids\"][:]\n    graph.add_edges_from(edges.tolist())\n\n    # collect node attributes\n    for name in group[\"nodes/attrs\"]:\n        ds = group[f\"nodes/attrs/{name}\"]\n        for node, val in zip(nodes, ds[:]):\n            val = val.tolist() if val.size &gt; 1 else val.item()\n            graph.nodes[node.item()][name] = val\n\n    # collect edge attributes]\n    for name in group[\"edges/attrs\"]:\n        ds = group[f\"edges/attrs/{name}\"]\n        for edge, val in zip(edges, ds[:]):\n            val = val.tolist() if val.size &gt; 1 else val.item()\n            source, target = edge.tolist()\n            graph.edges[source, target][name] = val\n\n    return graph\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.read(path)","title":"<code>path</code>","text":"(<code>Path</code>)           \u2013            <p>The path to the root of the geff zarr, where the .attrs contains the geff  metadata</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write","title":"write","text":"<pre><code>write(graph: Graph, position_attr: str, path: str | Path, axis_names: list[str] | None = None, axis_units: list[str] | None = None)\n</code></pre> <p>Write a networkx graph to the geff file format</p> <p>Parameters:</p> Source code in <code>src/geff/networkx/io.py</code> <pre><code>def write(\n    graph: nx.Graph,\n    position_attr: str,\n    path: str | Path,\n    axis_names: list[str] | None = None,\n    axis_units: list[str] | None = None,\n):\n    \"\"\"Write a networkx graph to the geff file format\n\n    Args:\n        graph (nx.Graph): a networkx graph where every node has a position attribute\n        position_attr (str): the name of the position attribute present on every node\n        path (str | Path): the path to the output zarr. Opens in append mode,\n            so will only overwrite geff-controlled groups.\n        axis_names (Optional[list[str]], optional): The names of the spatial dims\n            represented in position attribute. Defaults to None.\n        axis_units (Optional[list[str]], optional): The units of the spatial dims\n            represented in position attribute. Defaults to None.\n    \"\"\"\n    if nx.is_empty(graph):\n        warnings.warn(f\"Graph is empty - not writing anything to {path}\", stacklevel=2)\n        return\n    # open/create zarr container\n    group = zarr.open(path, \"a\")\n\n    # write meta-datajj\n    group.attrs[\"geff_version\"] = geff.__version__\n    group.attrs[\"position_attr\"] = position_attr\n    group.attrs[\"directed\"] = isinstance(graph, nx.DiGraph)\n    roi_min, roi_max = get_roi(graph, position_attr=position_attr)\n    group.attrs[\"roi_min\"] = roi_min\n    group.attrs[\"roi_max\"] = roi_max\n    if axis_names:\n        graph.attrs[\"axis_names\"] = axis_names\n    if axis_units:\n        graph.attrs[\"axis_units\"] = axis_units\n\n    # get node and edge IDs\n    nodes_list = list(graph.nodes())\n    nodes_arr = np.array(nodes_list)\n    edges_list = list(graph.edges())\n    edges_arr = np.array(edges_list)\n\n    # write nodes\n    group[\"nodes/ids\"] = nodes_arr\n\n    # write node attributes\n    for name in get_node_attrs(graph):\n        # TODO: handle missing values\n        group[f\"nodes/attrs/{name}\"] = np.array([graph.nodes[node][name] for node in nodes_list])\n\n    # write edges\n    group[\"edges/ids\"] = edges_arr\n\n    # write edge attributes\n    for name in get_edge_attrs(graph):\n        group[f\"edges/attrs/{name}\"] = np.array([graph.edges[edge][name] for edge in edges_list])\n</code></pre>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>a networkx graph where every node has a position attribute</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(position_attr)","title":"<code>position_attr</code>","text":"(<code>str</code>)           \u2013            <p>the name of the position attribute present on every node</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>the path to the output zarr. Opens in append mode, so will only overwrite geff-controlled groups.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(axis_names)","title":"<code>axis_names</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The names of the spatial dims represented in position attribute. Defaults to None.</p>"},{"location":"reference/geff/networkx/io/#geff.networkx.io.write(axis_units)","title":"<code>axis_units</code>","text":"(<code>Optional[list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>The units of the spatial dims represented in position attribute. Defaults to None.</p>"},{"location":"reference/geff/spatial_graph/","title":"geff.spatial_graph","text":""},{"location":"reference/geff/spatial_graph/#geff.spatial_graph","title":"geff.spatial_graph","text":""},{"location":"reference/geff/spatial_graph/io/","title":"geff.spatial_graph.io","text":""},{"location":"reference/geff/spatial_graph/io/#geff.spatial_graph.io","title":"geff.spatial_graph.io","text":""},{"location":"reference/geff/utils/","title":"geff.utils","text":""},{"location":"reference/geff/utils/#geff.utils","title":"geff.utils","text":"<p>Functions:</p> <ul> <li> <code>validate</code>             \u2013              <p>Check that the structure of the zarr conforms to geff specification</p> </li> </ul>"},{"location":"reference/geff/utils/#geff.utils.validate","title":"validate","text":"<pre><code>validate(path: str | Path)\n</code></pre> <p>Check that the structure of the zarr conforms to geff specification</p> <p>Parameters:</p> Source code in <code>src/geff/utils.py</code> <pre><code>def validate(path: str | Path):\n    \"\"\"Check that the structure of the zarr conforms to geff specification\n\n    Args:\n        path (str | Path): Path to geff zarr\n    \"\"\"\n    # Check that directory exists\n    assert os.path.exists(path), f\"Directory {path} does not exist\"\n\n    graph = zarr.open(path, mode=\"r\")\n\n    # graph attrs validation\n    # Raises pydantic.ValidationError or ValueError\n    GeffMetadata(**graph.attrs)\n\n    assert \"nodes\" in graph, \"graph group must contain a nodes group\"\n    nodes = graph[\"nodes\"]\n\n    # ids and attrs/position are required and should be same length\n    assert \"ids\" in nodes, \"nodes group must contain an ids array\"\n    assert \"attrs/position\" in nodes, \"nodes group must contain an attrs/position array\"\n\n    # Attribute array length should match id length\n    for attr in nodes[\"attrs\"].keys():\n        attr_len = nodes[\"attrs\"][attr].shape[0]\n        id_len = nodes[\"ids\"].shape[0]\n        assert (\n            attr_len == id_len\n        ), f\"Node attribute {attr} has length {attr_len}, which does not match id length {id_len}\"\n\n    assert \"edges\" in graph, \"graph group must contain an edge group\"\n    edges = graph[\"edges\"]\n\n    # Edges only require ids which contain nodes for each edge\n    assert \"ids\" in edges, \"edge group must contain ids array\"\n    id_shape = edges[\"ids\"].shape\n    assert (\n        id_shape[-1] == 2\n    ), f\"edges ids must have a last dimension of size 2, received shape {id_shape}\"\n</code></pre>"},{"location":"reference/geff/utils/#geff.utils.validate(path)","title":"<code>path</code>","text":"(<code>str | Path</code>)           \u2013            <p>Path to geff zarr</p>"}]}